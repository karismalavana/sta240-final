---
title: "Scenario 2"
output: scenario2_notebook
---

```{r}
# Function to generate customer arrival times (same as Scenario 1)
generate_arrival_times <- function(lambda_A, hours) {
  total_time <- hours * 60
  arrivals <- numeric(0)
  current_time <- 0
  while (current_time <= total_time) {
    current_time <- current_time + rexp(1, rate = lambda_A / 60)
    if (current_time <= total_time) {
      arrivals <- c(arrivals, current_time)
    }
  }
  arrivals
}

# Function to generate service times (modified for chef-dependent rate)
generate_service_times <- function(num_customers, num_chefs) {
  lambda_S <- 3 * num_chefs  # Service rate depends on number of chefs
  rexp(num_customers, rate = lambda_S / 60)
}

# Enhanced queue simulation for multiple tables and chefs
simulate_queue_scenario2 <- function(arrivals, service_times, num_tables, num_chefs) {
  num_customers <- length(arrivals)
  if (num_customers == 0) {
    stop("No customers arrived during the simulation period.")
  }
  
  # Initialize tracking variables
  table_departure_times <- matrix(0, nrow = num_tables, ncol = 1)  # Track each table
  waiting_times <- numeric(num_customers)
  queue_lengths <- numeric(num_customers)
  down_time <- 0
  revenue <- 0
  
  for (i in 1:num_customers) {
    # Find earliest available table
    next_available_time <- min(table_departure_times)
    available_table <- which.min(table_departure_times)
    
    if (arrivals[i] >= next_available_time) {
      # No waiting required
      waiting_times[i] <- 0
      table_departure_times[available_table] <- arrivals[i] + service_times[i]
      revenue <- revenue + 50  # Add revenue for served customer
      
      # Calculate down-time
      if (arrivals[i] > next_available_time) {
        down_time <- down_time + (arrivals[i] - next_available_time)
      }
    } else {
      # Customer must wait
      waiting_times[i] <- next_available_time - arrivals[i]
      table_departure_times[available_table] <- next_available_time + service_times[i]
      revenue <- revenue + 50
    }
    
    # Calculate current queue length
    queue_lengths[i] <- sum(arrivals <= arrivals[i] & 
                          apply(table_departure_times, 1, function(x) x > arrivals[i]))
  }
  
  # Calculate costs and profit
  labor_cost <- num_chefs * 40 * 12  # $40 per hour per chef, 12 hours
  profit <- revenue - labor_cost
  
  list(
    waiting_times = waiting_times,
    queue_lengths = queue_lengths,
    down_time = down_time,
    revenue = revenue,
    labor_cost = labor_cost,
    profit = profit,
    table_utilization = 1 - (down_time / (12 * 60 * num_tables))
  )
}

# Enhanced metrics calculation
calculate_metrics_scenario2 <- function(results) {
  list(
    avg_waiting_time = mean(results$waiting_times),
    max_waiting_time = max(results$waiting_times),
    p95_waiting_time = quantile(results$waiting_times, 0.95),
    avg_queue_length = mean(results$queue_lengths),
    max_queue_length = max(results$queue_lengths),
    p95_queue_length = quantile(results$queue_lengths, 0.95),
    total_down_time = results$down_time / 60,
    revenue = results$revenue,
    labor_cost = results$labor_cost,
    profit = results$profit,
    table_utilization = results$table_utilization
  )
}
```

```{r}
# Parameters for Scenario 2
lambda_A <- 10  # Customer arrival rate (per hour)
hours <- 12     # Operating hours (10 AM - 10 PM)
num_tables <- 5 # Number of tables

# Test different numbers of chefs
results_by_chef <- list()
for(num_chefs in 1:10) {
  # Generate arrivals and service times
  arrival_times <- generate_arrival_times(lambda_A, hours)
  service_times <- generate_service_times(length(arrival_times), num_chefs)
  
  # Run simulation
  simulation_results <- simulate_queue_scenario2(arrival_times, service_times, 
                                               num_tables, num_chefs)
  
  # Calculate metrics
  results_by_chef[[num_chefs]] <- calculate_metrics_scenario2(simulation_results)
}
```

```{r}
# Visualize results across different chef counts
# Create data frames for plotting
chef_metrics <- data.frame(
  num_chefs = 1:10,
  avg_wait = sapply(results_by_chef, function(x) x$avg_waiting_time),
  profit = sapply(results_by_chef, function(x) x$profit),
  queue_length = sapply(results_by_chef, function(x) x$avg_queue_length)
)

# Plot profit vs number of chefs
plot(chef_metrics$num_chefs, chef_metrics$profit, type = "l",
     main = "Profit vs Number of Chefs",
     xlab = "Number of Chefs", ylab = "Profit ($)")

# Plot average waiting time vs number of chefs
plot(chef_metrics$num_chefs, chef_metrics$avg_wait, type = "l",
     main = "Average Waiting Time vs Number of Chefs",
     xlab = "Number of Chefs", ylab = "Average Wait (minutes)")

# Plot average queue length vs number of chefs
plot(chef_metrics$num_chefs, chef_metrics$queue_length, type = "l",
     main = "Average Queue Length vs Number of Chefs",
     xlab = "Number of Chefs", ylab = "Average Queue Length")
```

```{r}
# Find optimal number of chefs
optimal_chefs <- which.max(sapply(results_by_chef, function(x) x$profit))
cat("Optimal number of chefs:", optimal_chefs, "\n")
cat("Maximum profit: $", results_by_chef[[optimal_chefs]]$profit, "\n")
cat("Average waiting time with optimal staffing:", 
    results_by_chef[[optimal_chefs]]$avg_waiting_time, "minutes\n")
cat("Average queue length with optimal staffing:", 
    results_by_chef[[optimal_chefs]]$avg_queue_length, "\n")
```

Key changes from Scenario 1:
1. Added support for multiple tables
2. Implemented chef-dependent service rates
3. Added financial calculations (revenue, costs, profit)
4. Created analysis across different chef counts
5. Enhanced visualization for business metrics

Would you like me to explain any part of the code in more detail or add additional analyses?